# EventEmitter
EventEmitter is a class/constructor function in Node.js which is heavaly used in Node.js App.
It manages event-driven architecture of Node.
The certain kind of objects called as 'emitters' ( instances of EventEmitter class ) emit named events to call listeners.

emitters are instances of the EventEmitter class, where we can register new events, on which emit we can execute qregitered listeners or listener on that event.

## So 3 main things:
emitter ===> instance of the EventEmitter
emitter.on method ===> to create new events and register listeners to that event.
emitter.emit method ===> to execute listeners on the specific event

## Important things
1. emit(eventname) does not returns anything it just calls listeners.
2. emit( eventname ) calls regitered listeners syncronous way uses `for loop`




1. Creation
const EventEmitter = require('events');
class CustomEmitter extends EventEmitter {};
const instanceEvents = new CustomEmitter();

2. Registration
instanceEvents.on('event1', () => {});
instanceEvents.on('event1', () => {});

instanceEvents.on('event2', () => {});

3. Registration for Once Call
instanceEvents.once('onceevent', () => {})

4. Execution
instanceEvents.emit('event1');
instanceEvents.emit('event1');

instanceEvents.emit('onceevent'); // after run from __events 'onceevent' event is DELETED

5. Asyncronous Execution of Callback
myEmitter.on('event', (a, b) => {
  setImmediate(() => {
    console.log('this happens asynchronously');
  });
});

6. Error events
As a best practice, listeners should always be added for the 'error' events.
myEmitter.on('error', (err) => {
  console.error('whoops! there was an error');
});
myEmitter.emit('error', new Error('whoops!'));
// Prints: whoops! there was an error

7. Aync Callback
Using async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:
The 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.

8. EventNames ( [] Array )
instanceEvents.eventNames() // returns [ 'event1', 'event2', 'event3' ]

9. MaxListeners ( integer )
Returns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.
instanceEvents.getMaxListeners() // returns 6

10.listenerCount ( integer )
instanceEvents.listenerCount('event1') // returns 3

11. listeners ( [] functions )
instanceEvents.listeners('event1');

12. removeListener // EventEmitter
instanceEvents.removeListener('event1', CallbackName)

13. prependListener (EventEmitter)
Adds the listener function to the beginning of the listeners array for the event named eventName. 
instanceEvents.prependListener('event1', () => {})

14. prependOnceListener
callback will be prepended in the first place and will be executed only the first .emit() once event the event itself was note once type
Adds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.
instanceEvents.prependOnceListener('event1', () => {})